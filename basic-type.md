# Базовые типы в Go 

- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);


<a id=""></a>

## Целые числа.

Для представления целочисленных переменных в Go есть ряд типов, различающихся лишь размерностью и отсутствием или наличием знака в них:

- знаковые: `int`, `int8`, `int16`, `int32`, `int64`;
- беззнаковые: `uint`, `uint8`, `uint16`, `uint32`, `uint64`.

Если размерности `int64` недостаточно, можно воспользоваться типом `big.Int` из пакета `math/big`.

> Все типы стандартной спецификации реализованы для всех заявленных архитектур. Однако типы `int`, `uint` будут 32- или 64-битными в зависимости от платформы.

<a id=""></a>

## Числа с плавающей точкой.

Числа с плавающей точкой представлены в двух вариантах: комплексные и вещественные. Как и у целочисленных типов, у них есть разные размерности:

- комплексные: `complex64`, `complex128`;
- вещественные: `float32`, `float64`.

Двукратную разницу в размерности легко объяснить: переменные типа `complex` состоят из двух компонентов типа `float`.

<a id=""></a>

## Арифметические операции

Для числовых типов доступны следующие арифметические операции:
`+` — сложение,
`-` — вычитание,
`*` — умножение,
`/` — деление нацело,
`%` — остаток от деления.

Как и в языке С, для этих операций предусмотрена конструкция сокращения `a = a + b` до `a += b`:

```go
var a int 
a = 5
a *= 2 // 'a = a * 2'; 10 
```

Также доступны операции инкремента и декремента — сокращения `a = a + 1` и `a = a - 1` соответственно. В отличие, например, от С++, в Go реализованы только постфиксные версии этих операций.

```go
var a int
a = 5
a++ // 'a = a + 1'; 6
a-- // 'a = a - 1'; 5 
```

<a id=""></a>

## Булевы значения

Для работы с логическими выражениями в Go представлен базовый тип `bool`, который принимает значения `true` и `false`:

```go
var a bool
a = true
a = false 
```

<a id=""></a>

## Строки.

В Go существует встроенный тип `string` для представления текстовых данных:

```go
var a string
a = "Hello, world!" 
```

Строки в Go представляют собой массив из значений типа `byte`. По этой причине к элементам строки можно обращаться по индексу, а к самим строкам применима встроенная функция `len()`, которая возвращает её длину в байтах:

```go
var a string
a = "abc"
println(len(a)) // 3 
```

Строка хранится как массив байт. Строки неизменяемы. Символ исправить нельзя, можно только заменить строку целиком:

```go
var a string
a = "abc"
println(a[2]) // выведет значение второго байта 99
// строки в Go неизменяемы, нельзя написать a[2] = 10
a[2] = 10 // здесь будет ошибка 
```

В данном случае длина строки в байтах равна количеству элементов, но это не всегда так. Дело в том, что Go из коробки поддерживает `Unicode`, а значит, строки могут содержать символы, не входящие в таблицу ASCII и не умещающиеся в один байт:

```go
var a string
a = "абц"
println(len(a)) // 6 
```

По этой же причине обращение по индексу иногда может возвращать неожидаемое значение:

```go
var a string
a = "абц"
println(a[5]) // 134 
```

Для работы с Unicode в Go предусмотрен встроенный тип `rune`, способный вместить больше одного байта — любой символ таблицы `Unicode`. Другими словами, типе `rune` - порядковый номер символа в таблицы `Unicode`. Например, с помощью него можно получить корректное количество символов из предыдущего примера:

```go
import (
	"fmt"
	"unicode/utf8"
)

func main() {
	var line string
	line = "абц"
	// неожиданное количество символов
	fmt.Println(len(line)) //6
	// правильное количество символов
	println(utf8.RuneCountInString(line)) // 3
	// или проще (без дополнительных пакетов)
    // переводим строку в `rune`
	runes := []rune(line)
    // считаем количество РУН
	fmt.Println(len(runes)) //3
}
```

Строковые значения в Go можно представить ещё одним способом. Если заключить строковое значение в обратные апострофы (` `), а не двойные кавычки `""`, то форматирование строки будет автоматически преобразовано в управляющие символы:

```go
var stringFormattedVar string
// следующие выражения равнозначны 
stringFormattedVar = "Hello,\nworld!\n\t\"quote!\""
stringFormattedVar = `Hello,
world!
        "quote!"`
```

<a id=""></a>

## Пользовательские типы

Как и большинство типизированных языков, Go позволяет программисту декларировать собственные типы. С помощью определений вы можете создавать новые типы, улучшая читаемость кода. Из-за строгости типизации вы ограничиваете определениями в том числе применимость функций и конструкций к вашим типам:

```go
type Name string
type Fruit string

var fruit Fruit
var name Name


fruit = "Apple"
name = fruit // ошибка типизации
             // cannot use fruit (variable of type Fruit) as type Name in assignment 
```

Чтобы исправить ошибку, нужно явно привести `fruit` к типу `Name` или наоборот.

Для пользовательских типов можно определять методы.

```go
// декларация пользовательского типа
type MyType string
// декларация метода для пользовательского типа
func (mt MyType) MethodForMyType() {
    //логика метода
} 
```

> **Важно!** Определять методы для встроенных типов в Go нельзя.

<a id=""></a>

## Приведение типов


Чтобы привести один тип к другому, в Go используется такой синтаксис: type(variable). Проиллюстрируем на предыдущем примере:

```go
type Name string
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = Name(fruit) // так, после приведения типов, работает 
```

<a id=""></a>

### Пример преобразования для типа `string`:

Нужно напечатать первую букву какой-то строки. Но встроенная неформатирующая функция печати выведет 72, первый байт массива, в котором хранится строка. 

```go
var str string
str = "Hello, world!" 
println(str[0]) //72 
```

Чтобы это поведение исправить нужно использовать "приведение типов"

```go
package main

func main() {
    var str string
    str = "Hello, world!"
    println(string(str[0]))
} 
```

<a id=""></a>

## Конвертация из `string` то `int` (`float`, `bool`) и обратно:

Для конвертации типов `string` то `int` и обратно существует специальный модуль `strconv`.

 - из `string` то `int` - `strconv.Atoi(s)` (Atoi звучит как "альфа to int")
 - из `int` то `string` - `strconv.Itoa(s)`

 ```go
i, err := strconv.Atoi("-42")
s := strconv.Itoa(-42)
```

Функции синтаксического анализа `strconv.ParseBool`, `strconv.parseFloat`, `strconv.parseInt` и `strconv.ParseUint` преобразуют строки в соответствующие значения:

```go
b, err := strconv.ParseBool("true")
// преобразует к float, 
// где 64 - разрадность, т.е. float64
f, err := strconv.ParseFloat("3.1415", 64)
// преобразует к int, 
// где 10 - система счисления, например, двоичная - будет 2
// 64 - разрадность, т.е. int64
i, err := strconv.ParseInt("-42", 10, 64)
// преобразует к беззнаковому uint, 
// где 10 - система счисления, например, двоичная - будет 2
// 64 - разрадность, т.е. uint64
u, err := strconv.ParseUint("42", 10, 64)
```

Функции синтаксического анализа возвращают самый широкий тип (`float64`, `int64` и `uint64`), но если аргумент `size` указывает меньшую ширину, результат может быть преобразован в этот более узкий тип без потери данных:

```go
s := "2147483647" // biggest int32
i64, err := strconv.ParseInt(s, 10, 32)
...
i := int32(i64)
```

Функции `strconv.FormatBool`, `strconv.FormatFloat`, `strconv.FormatInt` и `strconv.FormatUint` преобразуют значения в строки:

```go
s := strconv.FormatBool(true)
// где 2 - система счисления
s := strconv.FormatInt(-42, 2) //-101010
// где 10 - система счисления
s := strconv.FormatUint(-42, 10) // -42
s := strconv.FormatFloat(3.1415, 'E', -1, 64)
```

#### `strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) string`:

- `fmt` - может быть одним из следующих: 
  - `'b'` (`-ddddp±ddd`, двоичный показатель степени), 
  - `'e'` (`-d.dddde±dd`, десятичный показатель степени), 
  - `'E'` (`-d.ddddE±dd`, десятичный показатель степени), 
  - `'f'` (`-ddd.dddd`, без экспоненты), 
  - `'g'` (`'e'` для больших степеней, `'f'` в противном случае), 
  - `'G'` (`'E'` для больших степеней, `'f'` в противном случае), 
  - `'x'` (`-0xd.ddddp±ddd`, шестнадцатеричная дробь и двоичный показатель степени) 
  - `'X'` (`-0Xd.ddddP±ddd`, шестнадцатеричная дробь и двоичный показатель степени).
- `prec` - cпециальная точность -1 использует наименьшее необходимое количество цифр, чтобы ParseFloat точно вернул f. Контролирует количество цифр (исключая показатель степени), напечатанных в форматах `'e'`, ​`​'E'`, `'f'`, `'g'`, `'G'`, `'x'` и `'X'`. Для `'e'`, ​`​'E'`, `'f'`, `'x'` и `'X'` это количество цифр после запятой. Для `'g'` и `'G'` это максимальное количество значащих цифр (нули в конце удаляются).
- `bitSize` - округляет результат, предполагая, что оригинал был получен из значения с плавающей запятой (32 для `float32`, 64 для `float64`).

Пример использования `strconv.FormatFloat()`:

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	str := "Not a number"
	if num, err := strconv.ParseFloat(str, 64); err != nil {
		e := err.(*strconv.NumError)
		fmt.Println("Func:", e.Func)
		fmt.Println("Num:", e.Num)
		fmt.Println("Err:", e.Err)
		fmt.Println(err)
	} else {
		fmt.Println(num)
	}

    // Func: ParseFloat
	// Num: Not a number
	// Err: invalid syntax
	// strconv.ParseFloat: parsing "Not a number": invalid syntax
}
```